# Chapter2

- 개방폐쇄 원칙 필요성
    - 새로운 클래스를 추가시 여러이름이 생기며 다양한 동작간의 관계를 이해하기가 어려움
    - 반복하면서 수행하는 로직을 바꾸려면 여기저기 바꿔야하는 문제가 발생
    - 한번에 비지니스로직을 섞어서 만들경우 코드가 점점 복잡해지며 분리하기가 어려워진다
    - 코드를 직접 바꾸지않고 해당 메서드나 클래스의 동작을 바꾸는방법 
- 개방폐쇄 원칙 적용
  - 기존 메서드의바디를 바꿀 필요없이 구현을 인수로 전달하며 변경없이도(close) 확장은 개방(open)
  - 구현하고 검증된 코드를 수정할 일이 최소화 된다

?? 3.4.1 함수형인터페이스인스턴스만들기 예제3-6(54p)
- 이해가 잘안감

이때 인터페이스에 모든걸 다 꾸겨넣은 갓 인터페이스는 지양하자
구현클래스는 인터페이에서 정의한 모든 연산의 구현코드를 제공해야하기때문에

인터페이스를 지나치게 세밀하게 나눠두면 안티응집도 문제가발생하며 유지보수가 어렵다

코드베이스에 불필요한 추상화를 추가해 일을 복잡하게 만들 필요가 없다

- 명시적api
  - 어떤 동작을 수행하는지 잘 성명됨
  - 사용하기도쉬움
  - 메소드의 용도가 특정 상황에 국한되어 각 상황에 맞는 새로운 매소드를 많이 만들어야함
- 암묵적api
  - 처음 사용하기 어렵다
  - 문서화 필수
  - 모든 상황을 단순한 api로 처리할 수 있다

원시값으로 값을 반환시 다양한 결과를 반환할수 없어 유연성이 떨어진다.
새 도메인클래스를 만들어 해결

내보내기 기능을만들때 exporter 인터페이스를 만들어 구현하도록하면 다양한 포맷지원 가능

단 반환형식을 void 비추천 아무 도움도안됨 기능을 파악하기도어려움 인터페이스에서 얻을 정보가 하나도 없다

- 예외처리를 해야하는 케이스
  - 문서화
  - 형식안정성
  - 관심사분리

- 확인된예외
  - try/catch 사용해 처리
- 미확인예외
  - throw로 처리

과연 어떤걸 확인된예외 처리하고 어떤걸 미확인예외처리해야할까?
- 예외가 발생했을때 프로그램이 회복되도록 강제할것인지 스스로 생각하면 답이 나옴
- 대다수 예외를 미확인 예외로 지정하고 꼭 필요한 상황에서만 확인된 예외로 지정해 불필요한 코드를 줄이자

- Validator 클래스를 권하는이유
  - 검증로직을 재사용해 코드중복x
  - 로직을 독립적으로 유닛테스트 가능
  - srp를 따른다

- 과도한 세밀함
  - 너무많은 설정이 필요하고 여러 예외를 선언해야하며 사용자가 이 모든 예외를 처리해야하므로 생산성이 떨어진다
  - 오류목록을 사용자에게 제공할수도없다
- 과도하게 덤덤함
  - 모든예외를 미확인 예외로 던지는 경우
  - 구체적인 회복 로직을 만들 수 없다

- notification과같은 error클래스를 만들어서 add하며 여러 에러를 수집할수있게한다
  - ??앞의 섬세와의 차이는 여러 에러를 볼수있다는점인가? 71p

- 예외 생성가이드라인
  - 특정 구현에 종속된 예외를 던지면 api 캡슐화가 깨지므로 주의하자
  - 예외로 흐름을 제어하지말자
- 예외대안으로 null 을 던지는건 절대 금지

- 그래이들
  - 가독성이 떨어지고 작업하기 귀찮은 xml이 아닌 dsl을 사용